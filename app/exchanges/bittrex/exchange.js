"use strict";
const createApiInstance = require('node-bittrex-api').createInstance;
const logger = require('winston');
const _ = require('lodash');
const Big = require('big.js');
const Errors = require('../../errors');
const DateTimeHelper = require('../../datetime-helper');
const AbstractExchangeClass = require('../../abstract-exchange');
const SubscriptionManagerClass = require('./subscription-manager');

const exchangeType = 'bittrex';

// list of possible interval for klines
const supportedKlinesIntervals = [
  '1m', '5m', '30m',
  '1h',
  '1d'
]
const klinesIntervalsMapping = {
    '1m':'oneMin', '5m':'fiveMin', '30m':'thirtyMin',
    '1h':'hour',
    '1d':'day'
}
const defaultKlinesInterval = '5m';

// list of all possible features (should be enabled by default if supported by class)
const supportedFeatures = {
    'pairs':{enabled:true},
    'tickers':{enabled:true, withoutPair:true}, 'wsTickers':{enabled:true, emulated:false},
    'orderBooks':{enabled:true}, 'wsOrderBooks':{enabled:true, emulated:false},
    'trades':{enabled:true}, 'wsTrades':{enabled:true, emulated:false},
    'klines':{enabled:true,intervals:supportedKlinesIntervals,defaultInterval:defaultKlinesInterval}, 'wsKlines':{enabled:true,emulated:true,intervals:supportedKlinesIntervals,defaultInterval:defaultKlinesInterval},
    'orders':{enabled:true, withoutPair:true},
    'openOrders':{enabled:true, withoutPair:true},
    'closedOrders':{enabled:true, withoutPair:true, completeHistory:false},
    'balances':{enabled:true, withoutCurrency:true}
};

class Exchange extends AbstractExchangeClass
{

/**
 * Constructor
 *
 * @param {string} exchangeId exchange identifier (ex: bittrex)
 * @param {string} exchangeName exchange name (ex: Bittrex)
 * @param {object} config full config object
 */
 constructor(exchangeId, exchangeName, config)
 {
    super(exchangeId, exchangeType, exchangeName, supportedFeatures, config);
    let opt = {
        apikey:config.exchanges[exchangeId].key,
        apisecret:config.exchanges[exchangeId].secret,
        verbose:false,
        stream:false,
        cleartext:false
    };
    this._client = createApiInstance(opt);
    this._ignoreRestrictedPairs = (true === config.exchanges[exchangeId].ignoreRestrictedPairs);
    this._limiterGlobal = this._getRateLimiter(config.exchanges[exchangeId].throttle.global.maxRequestsPerSecond);
    let subscriptionManager = new SubscriptionManagerClass(this, config);
    this._setSubscriptionManager(subscriptionManager);
}

/**
 * Extract error from the error returned by API
 *
 * @param {object} error error returned by API
 * @return {string|object}
 */
_parseError(error)
{
    // not an error generated by node-bittrex-api
    if (undefined === error.success && error instanceof Error)
    {
        return error;
    }
    // network error (ex: DNS pb)
    if (null !== error.error && error.error instanceof Error)
    {
        return error.error;
    }
    // http error returned by Bittrex (ex: wrong url)
    if (null !== error.result)
    {
        return error.result;
    }
    // Bittrex API error
    return error.message;
}

/**
 * Indicates whether or not error is an authentication error
 *
 * @param {string} message error message
 * @return {boolean}
 */
_isInvalidAuthError(message)
{
    switch (message)
    {
        case 'APIKEY_INVALID':
        case 'INVALID_SIGNATURE':
            return true;
    }
    return false;
}

/**
 * Returns all active pairs
 *
 * @return {Promise}
 */
/*
Raw output example for GET https://bittrex.com/api/v1.1/public/getmarkets

{
    "success":true,
    "message":"",
    "result":[
        {
            "MarketCurrency":"LTC",
            "BaseCurrency":"BTC",
            "MarketCurrencyLong":"Litecoin",
            "BaseCurrencyLong":"Bitcoin",
            "MinTradeSize":0.01385042,
            "MarketName":"BTC-LTC",
            "IsActive":true,
            "IsRestricted": false,
            "Created":"2014-02-13T00:00:00",
            "Notice":null,
            "IsSponsored":null,
            "LogoUrl":"https://bittrexblobstorage.blob.core.windows.net/public/6defbc41-582d-47a6-bb2e-d0fa88663524.png"
        },
        {
            "MarketCurrency":"DOGE",
            "BaseCurrency":"BTC",
            "MarketCurrencyLong":"Dogecoin",
            "BaseCurrencyLong":"Bitcoin",
            "MinTradeSize":625.00000000,
            "MarketName":"BTC-DOGE",
            "IsActive":true,
            "IsRestricted": false,
            "Created":"2014-02-13T00:00:00",
            "Notice":null,
            "IsSponsored":null,
            "LogoUrl":"https://bittrexblobstorage.blob.core.windows.net/public/a2b8eaee-2905-4478-a7a0-246f212c64c6.png"
        }
    ]
}

*/
_getPairs()
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getmarkets((response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                let list = {};
                // count active pairs
                let activePairs = 0;
                _.forEach(response.result, (entry) => {
                    // ignore if inactive
                    if (!entry.IsActive)
                    {
                        return;
                    }
                    /*
                        Ignore restricted pairs if enabled in config
                        See https://github.com/Bittrex/bittrex.github.io/issues/78
                     */
                    if (entry.IsRestricted && self._ignoreRestrictedPairs)
                    {
                        return;
                    }
                    ++activePairs;
                    list[entry.MarketName] = {
                        pair:entry.MarketName,
                        baseCurrency: entry.BaseCurrency,
                        currency: entry.MarketCurrency,
                        limits:{
                            rate:{
                               min:0.00000001,
                               max:null,
                               step:0.00000001,
                               precision:8
                            },
                            quantity:{
                                min:parseFloat(entry.MinTradeSize),
                                max:null,
                                step:0.00000001,
                                precision:8
                            },
                            /*
                            The minimum trade value for orders is supposed to be 100,000 Satoshis (.00100000), see https://support.bittrex.com/hc/en-us/articles/115003004171-What-are-my-trade-limits-
                            But the API is still returning DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT error when total amount is < 0.0005 (with an error margin)
                            - 0.00049914 can be fine
                            - 0.00049855 can trigger the error
                            */
                            price:{
                                min:0.0005,
                                max:null
                            }
                        }
                    }
                });
                // no active pair something must be wrong on exchange
                if (0 == activePairs)
                {
                    if (0 == response.result.length)
                    {
                        logger.warn("Received no pairs from '%s' : something must be wrong with exchange", self.getId());
                    }
                    else
                    {
                        logger.warn("Received %d pairs from '%s' but none is in active state : something must be wrong with exchange", response.result.length, self.getId());
                    }
                }
                resolve(list);
            });
        });
    });
}

/**
 * Retrieve tickers for all pairs
 *
 * @return {Promise}
 */
/*
Raw output example for GET https://bittrex.com/api/v1.1/public/getmarketsummaries

{
    "success":true,
    "message":"",
    "result":[
        {
            "MarketName":"BTC-2GIVE",
            "High":0.00000074,
            "Low":0.00000071,
            "Volume":1748300.03203106,
            "Last":0.00000072,
            "BaseVolume":1.26515507,
            "TimeStamp":"2018-04-09T11:56:01.533",
            "Bid":0.00000071,
            "Ask":0.00000072,
            "OpenBuyOrders":119,
            "OpenSellOrders":914,
            "PrevDay":0.00000072,
            "Created":"2016-05-16T06:44:15.287"
        },
        {
            "MarketName":"BTC-ABY",
            "High":0.00000086,
            "Low":0.00000081,
            "Volume":4301219.03432162,
            "Last":0.00000082,
            "BaseVolume":3.57801245,
            "TimeStamp":"2018-04-09T11:59:33.9",
            "Bid":0.00000082,
            "Ask":0.00000084,
            "OpenBuyOrders":233,
            "OpenSellOrders":1680,
            "PrevDay":0.00000083,
            "Created":"2014-10-31T01:43:25.743"
        }
    ]
}

*/
async _getTickers()
{
    // we retrieve pairs to be able to ignore invalid ones
    const pairs = await this.getPairs(true);
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getmarketsummaries((response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                let list = {};
                _.forEach(response.result, (entry) => {
                    // ignore invalid pairs
                    if (undefined === pairs[entry.MarketName]) {
                        return;
                    }
                    let last = parseFloat(entry.Last);
                    let previousDay = parseFloat(entry.PrevDay);
                    let percentChange = 0;
                    if (previousDay > 0)
                    {
                        percentChange = ((last/previousDay) - 1) * 100;
                    }
                    list[entry.MarketName] = {
                        pair:entry.MarketName,
                        last: last,
                        priceChangePercent:percentChange,
                        sell: parseFloat(entry.Ask),
                        buy: parseFloat(entry.Bid),
                        high: parseFloat(entry.High),
                        low: parseFloat(entry.Low),
                        volume: parseFloat(entry.Volume),
                        timestamp: DateTimeHelper.parseUtcDateTime(entry.TimeStamp)
                    }
                });
                resolve(list);
            });
        });
    });
}

/**
 * Retrieve order book for a single pair

 * @param {string} pair pair to retrieve order book for
 * @param {integer} opt.limit maximum number of entries (for both ask & bids) (optional)
 * @param {object} opt.custom exchange specific options (will always be defined)
 * @return {Promise}
 */
 /*
 Raw output example for GET https://bittrex.com/api/v1.1/public/getorderbook?market=USDT-NEO&type=both

 {
     "success":true,
     "message":"",
     "result":{
         "buy":[
             {
                 "Quantity":0.51658382,
                 "Rate":50.20000000
             },
             {
                 "Quantity":299.56301220,
                 "Rate":50.13469042
             }
         ],
         "sell":[
             {
                 "Quantity":168.10400000,
                 "Rate":50.49355634
             },
             {
                 "Quantity":2.63506940,
                 "Rate":50.49355642
             }
         ]
     }
 }
 */
_getOrderBook(pair, opt)
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getorderbook({market:pair, type:'both'}, (response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                let result = {
                    buy:_.map(response.result.buy, (entry) => {
                        return {
                            rate:parseFloat(entry.Rate),
                            quantity:parseFloat(entry.Quantity)
                        }
                    }),
                    sell:_.map(response.result.sell, (entry) => {
                        return {
                            rate:parseFloat(entry.Rate),
                            quantity:parseFloat(entry.Quantity)
                        }
                    })
                }
                resolve(result);
            });
        });
    });
}

/**
 * Returns last trades
 *
 * @param {string} pair pair to retrieve trades for
 * @param {integer} opt.limit maximum number of entries (optional)
 * @param {object} opt.custom exchange specific options (will always be defined)
 * @return {Promise}
 */
 /*
 Raw output example for GET https://bittrex.com/api/v1.1/public/getmarkethistory?market=USDT-NEO

 {
     "success":true,
     "message":"",
     "result":[
         {
             "Id":24673441,
             "TimeStamp":"2018-04-09T14:09:34.393",
             "Quantity":0.25015311,
             "Price":49.16800000,
             "Total":12.29952811,
             "FillType":"FILL",
             "OrderType":"BUY"
         },
         {
             "Id":24673433,
             "TimeStamp":"2018-04-09T14:09:27.86",
             "Quantity":22.48100000,
             "Price":49.16800000,
             "Total":1105.34580800,
             "FillType":"FILL",
             "OrderType":"BUY"
         }
     ]
 }
*/
_getTrades(pair, opt)
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getmarkethistory({market:pair}, (response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                let list = [];
                _.forEach(response.result, (entry) =>{
                    let orderType = 'sell';
                    if ('BUY' == entry.OrderType)
                    {
                        orderType = 'buy';
                    }
                    list.push({
                        id:entry.Id,
                        quantity:entry.Quantity,
                        rate:entry.Price,
                        price:entry.Total,
                        orderType:orderType,
                        timestamp:DateTimeHelper.parseUtcDateTime(entry.TimeStamp)
                    })
                });
                resolve(list);
            });
        });
    });
}

/**
 * Returns charts data
 *
 * @param {string} pair pair to retrieve chart data for
 * @param {string} interval charts interval
 * @param {integer} fromTimestamp unix timestamp in seconds (not supported by Bittrex)
 * @param {integer} toTimestamp unix timestamp in seconds (not supported by Bittrex)
 * @return {Promise}
 */
 /*
 Raw output example for GET https://bittrex.com/Api/v2.0/pub/market/GetTicks?marketName=BTC-PTC&tickInterval=fiveMin

 {
    "success":true,
    "message":"",
    "result":[
        {
            "O":0.00000421,
            "H":0.00000421,
            "L":0.00000421,
            "C":0.00000421,
            "V":1250.00000000,
            "T":"2018-03-27T13:50:00",
            "BV":0.00526250
        },
        {
            "O":0.00000428,
            "H":0.00000428,
            "L":0.00000428,
            "C":0.00000428,
            "V":116.53270444,
            "T":"2018-03-27T14:10:00",
            "BV":0.00049875
        },
        {
            "O":0.00000420,
            "H":0.00000420,
            "L":0.00000420,
            "C":0.00000420,
            "V":1672.50001236,
            "T":"2018-03-27T14:45:00",
            "BV":0.00702449
        },
        {
            "O":0.00000415,
            "H":0.00000415,
            "L":0.00000407,
            "C":0.00000407,
            "V":43363.75417264,
            "T":"2018-03-27T14:50:00",
            "BV":0.17710378
        }
    ]
}
 */
async _getKlines(pair, interval, fromTimestamp, toTimestamp)
{
    let _interval = klinesIntervalsMapping[interval];
    let self = this;
    return new Promise((resolve, reject) => {
        self._client.getcandles({marketName:pair,tickInterval:_interval}, (response, error) => {
            if (null !== error)
            {
                let e = self._parseError(error);
                // must be a Bittrex error
                if ('string' == typeof (e))
                {
                    reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                }
                else
                {
                    reject(e);
                }
                return;
            }
            let list = [];
            _.forEach(response.result, (entry) =>{
                list.push({
                    timestamp:DateTimeHelper.parseUtcDateTime(entry.T),
                    open:parseFloat(entry.O),
                    high:parseFloat(entry.H),
                    low:parseFloat(entry.L),
                    close:parseFloat(entry.C),
                    volume:parseFloat(entry.V)
                })
            });
            resolve(list);
        });
    });
}

/**
 * Retrieve open orders for all pairs
 *
 * @return {Promise}
 */
/*
Raw output example for GET https://bittrex.com/api/v1.1/market/getopenorders?apikey=API_KEY

{
    "success":true,
    "message":"",
    "result":[
        {
            "Uuid":null,
            "OrderUuid":"14250e18-ac45-4742-9647-5ee3d5acc6b1",
            "Exchange":"BTC-WAVES",
            "OrderType":"LIMIT_SELL",
            "Quantity":110.80552162,
            "QuantityRemaining":110.80552162,
            "Limit":0.00248,
            "CommissionPaid":0,
            "Price":0,
            "PricePerUnit":null,
            "Opened":"2017-07-01T21:46:18.653",
            "Closed":null,
            "CancelInitiated":false,
            "ImmediateOrCancel":false,
            "IsConditional":false,
            "Condition":"NONE",
            "ConditionTarget":null
        },
        {
            "Uuid":null,
            "OrderUuid":"d3af561a-c3ac-4452-bf0e-a32854b558e5",
            "Exchange":"USDT-NEO",
            "OrderType":"LIMIT_BUY",
            "Quantity":2.33488048,
            "QuantityRemaining":2.33488048,
            "Limit":12,
            "CommissionPaid":0,
            "Price":0,
            "PricePerUnit":null,
            "Opened":"2017-08-07T08:43:58.45",
            "Closed":null,
            "CancelInitiated":false,
            "ImmediateOrCancel":false,
            "IsConditional":false,
            "Condition":"NONE",
            "ConditionTarget":null
        }
    ]
}

*/
_getOpenOrders()
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getopenorders({}, (response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        if (self._isInvalidAuthError(e))
                        {
                            reject(new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e));
                        }
                        else
                        {
                            reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                        }
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                let list = {};
                _.forEach(response.result, (entry) => {
                    let orderType;
                    // we only support buy or sell orders
                    switch (entry.OrderType)
                    {
                        case 'LIMIT_BUY':
                            orderType = 'buy';
                            break;
                        case 'LIMIT_SELL':
                            orderType = 'sell';
                            break;
                        default:
                            return;
                    }
                    let order = {
                        pair:entry.Exchange,
                        orderType:orderType,
                        orderNumber:entry.OrderUuid,
                        targetRate:parseFloat(entry.Limit),
                        quantity:parseFloat(entry.Quantity),
                        remainingQuantity:parseFloat(entry.QuantityRemaining),
                        openTimestamp:DateTimeHelper.parseUtcDateTime(entry.Opened)
                    }
                    // define targetPrice based on quantity & targetRate
                    order.targetPrice = parseFloat(new Big(order.quantity).times(order.targetRate).toFixed(8));
                    list[order.orderNumber] = order;
                });
                resolve(list);
            });
        });
    });
}

/**
 * Update a closed order
 * - recompute actualPrice from quantity & actualRate
 * - compute finalPrice from actualPrice & fees
 * - compute finalRate from finalPrice & quantity
 *
 * @param {object} order object
 */
_updateClosedOrder(order)
{
    // entry.Price returned by Bittrex is not computed correctly, so we recompute it
    let actualPrice = new Big(order.quantity).times(order.actualRate);
    let finalPrice;
    if ('buy' == order.orderType)
    {
        finalPrice = actualPrice.plus(order.fees.amount);
    }
    else
    {
        finalPrice = actualPrice.minus(order.fees.amount);
    }
    order.actualPrice = parseFloat(actualPrice.toFixed(8));
    order.finalPrice = parseFloat(finalPrice.toFixed(8));
    if (order.quantity > 0) {
        order.finalRate = parseFloat(finalPrice.div(order.quantity).toFixed(8));
    }
}

/**
 * Retrieve closed orders for all pairs
 *
 * @param {boolean} opt.completeHistory whether or not all orders should be retrieved (might not be supported on all exchanges)
 * @return {Promise}
 */
/*
Raw output example GET https://bittrex.com/api/v1.1/market/getorderhistory?apikey=API_KEY

{
    "success":true,
    "message":"",
    "result":[
        {
            "OrderUuid":"dee7c058-3f48-4e6c-bb69-e54d7faf9f98",
            "Exchange":"USDT-NEO",
            "TimeStamp":"2017-08-07T08:38:37.353",
            "OrderType":"LIMIT_SELL",
            "Limit":20,
            "Quantity":5.00033725,
            "QuantityRemaining":0,
            "Commission":0.250004801,
            "Price":100.19204559,
            "PricePerUnit":20.0003706,
            "IsConditional":false,
            "Condition":"NONE",
            "ConditionTarget":null,
            "ImmediateOrCancel":false,
            "Closed":"2017-08-07T08:38:37.947"
        },
        {
            "OrderUuid":"62d4368c-4363-4c9e-b992-9852189141eb",
            "Exchange":"USDT-ANS",
            "TimeStamp":"2017-08-06T22:31:05.44",
            "OrderType":"LIMIT_SELL",
            "Limit":16.11,
            "Quantity":2.4927,
            "QuantityRemaining":0,
            "Commission":0.1005181274,
            "Price":40.72509999,
            "PricePerUnit":16.12999999,
            "IsConditional":false,
            "Condition":"NONE",
            "ConditionTarget":null,
            "ImmediateOrCancel":false,
            "Closed":"2017-08-06T22:31:05.61"
        }
    ]
}

*/
_getClosedOrders(opt)
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getorderhistory({}, (response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        if (self._isInvalidAuthError(e))
                        {
                            reject(new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e));
                        }
                        else
                        {
                            reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                        }
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                let list = {};
                _.forEach(response.result, (entry) => {
                    let orderType;
                    let splittedPair = entry.Exchange.split('-');
                    let feesCurrency = splittedPair[0];
                    // we only support buy or sell orders
                    switch (entry.OrderType)
                    {
                        case 'LIMIT_BUY':
                            orderType = 'buy';
                            break;
                        case 'LIMIT_SELL':
                            orderType = 'sell';
                            break;
                        default:
                            return;
                    }
                    let quantity = parseFloat(entry.Quantity) - parseFloat(entry.QuantityRemaining);
                    let order = {
                        pair:entry.Exchange,
                        orderNumber:entry.OrderUuid,
                        orderType:orderType,
                        quantity:quantity,
                        actualRate:parseFloat(entry.Limit),
                        openTimestamp:DateTimeHelper.parseUtcDateTime(entry.TimeStamp),
                        closedTimestamp:DateTimeHelper.parseUtcDateTime(entry.Closed),
                        fees:{
                            amount:parseFloat(entry.Commission),
                            currency:feesCurrency
                        }
                    }
                    self._updateClosedOrder(order);
                    list[order.orderNumber] = order;
                });
                resolve(list);
            });
        });
    });
}

/**
 * Retrieves a single order (open or closed)
 *
 * @param {string} orderNumber
 * @param {string} pair pair (ex: USDT-NEO) (if exchange supports retrieving an order without the pair, value will be undefined)
 * @return {Promise}
 */
/*

Raw output example for GET https://bittrex.com/api/v1.1/account/getorder&uuid=0cb4c4e4-bdc7-4e13-8c13-430e587d2cc1

{
    "AccountId":null,
    "OrderUuid":"0cb4c4e4-bdc7-4e13-8c13-430e587d2cc1",
    "Exchange":"BTC-PTC",
    "Type":"LIMIT_SELL",
    "Quantity":1000,
    "QuantityRemaining":1000,
    "Limit":0.000009,
    "Reserved":1000,
    "ReserveRemaining":1000,
    "CommissionReserved":0,
    "CommissionReserveRemaining":0,
    "CommissionPaid":0,
    "Price":0,
    "PricePerUnit":null,
    "Opened":"2018-04-09T14:43:52.1",
    "Closed":null,
    "IsOpen":true,
    "Sentinel":"0cb4c4e4-bdc7-4e13-8c13-430e587d2cc1",
    "CancelInitiated":false,
    "ImmediateOrCancel":false,
    "IsConditional":false,
    "Condition":"NONE",
    "ConditionTarget":null
}
*/
_getOrder(orderNumber, pair)
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getorder({uuid:orderNumber}, (response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        if (self._isInvalidAuthError(e))
                        {
                            reject(new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e));
                        }
                        else
                        {
                            switch (e)
                            {
                                case 'INVALID_ORDER':
                                    reject(new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber, e));
                                    break;
                                default:
                                    reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                                    break;
                            }
                        }
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                // probably an invalid order number
                if (null === response.result)
                {
                    reject(new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber, response.message));
                    return;
                }
                let orderType;
                let orderState = 'open';
                let splittedPair = response.result.Exchange.split('-');
                let feesCurrency = splittedPair[0];
                if (null !== response.result.Closed)
                {
                    orderState = 'closed';
                }
                // we only support buy or sell orders
                switch (response.result.Type)
                {
                    case 'LIMIT_BUY':
                        orderType = 'buy';
                        break;
                    case 'LIMIT_SELL':
                        orderType = 'sell';
                        break;
                    default:
                        logger.warn(`Unknown order type '${response.result.Type}' for '${self.getId()}' order '${orderNumber}'`);
                        reject(new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber, e));
                        return;
                }
                let order = {
                    pair:response.result.Exchange,
                    orderType:orderType,
                    orderNumber:orderNumber,
                    openTimestamp:DateTimeHelper.parseUtcDateTime(response.result.Opened)
                }
                if ('open' == orderState)
                {
                    order.quantity = parseFloat(response.result.Quantity);
                    order.targetRate = parseFloat(response.result.Limit);
                    order.remainingQuantity = parseFloat(response.result.QuantityRemaining);
                    order.targetPrice = parseFloat(new Big(order.targetRate).times(order.quantity).toFixed(8));
                }
                else
                {
                    order.quantity = parseFloat(response.result.Quantity) - parseFloat(response.result.QuantityRemaining);
                    order.actualRate = parseFloat(response.result.Limit);
                    order.closedTimestamp = DateTimeHelper.parseUtcDateTime(response.result.Closed);
                    order.fees = {
                        amount:parseFloat(response.result.CommissionPaid),
                        currency:feesCurrency
                    }
                    self._updateClosedOrder(order);
                }
                resolve(order);
            });
        });
    });
}

/**
 * Creates a new order
 *
 * @param {string} orderType (buy|sell)
 * @param {string} pair pair to buy/sell
 * @param {float} targetRate expected buy/sell price
 * @param {float} quantity quantity to buy/sell
 * @return {Promise} Promise which will resolve to the number of the new order
 */
 /*
 Raw output example for GET https://bittrex.com/api/v1.1/market/buylimit?apikey=API_KEY&market=BTC-LTC&quantity=1.2&rate=1.3

{
    "success":true,
    "message":"",
    "result":{
        "uuid":"e606d53c-8d70-11e3-94b5-425861b86ab6"
    }
}
 */
_createOrder(orderType, pair, targetRate, quantity)
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            let params = {
                market:pair,
                quantity:quantity,
                rate:targetRate
            }
            // buy order
            if ('buy' == orderType)
            {
                self._client.buylimit(params, (response, error) => {
                    if (null !== error)
                    {
                        let e = self._parseError(error);
                        // must be a Bittrex error
                        if ('string' == typeof (e))
                        {
                            if (self._isInvalidAuthError(e))
                            {
                                reject(new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e));
                            }
                            else
                            {
                                switch (e)
                                {
                                    // invalid quantity
                                    case 'MIN_TRADE_REQUIREMENT_NOT_MET':
                                        reject(new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InvalidQuantity(self.getId(), pair, quantity, e));
                                        break;
                                    // invalid price
                                    case 'DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT':
                                        reject(new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InvalidPrice(self.getId(), pair, targetRate, quantity, e));
                                        break;
                                    // not enough funds
                                    case 'INSUFFICIENT_FUNDS':
                                        reject(new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InsufficientFunds(self.getId(), pair, targetRate, quantity, e));
                                        break;
                                    default:
                                        reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                                        break;
                                }
                            }
                        }
                        else
                        {
                            reject(e);
                        }
                        return;
                    }
                    // only return order number
                    return resolve(response.result.uuid);
                });
            }
            // sell order
            else
            {
                self._client.selllimit(params, (response, error) => {
                    if (null !== error)
                    {
                        let e = self._parseError(error);
                        // must be a Bittrex error
                        if ('string' == typeof (e))
                        {
                            if (self._isInvalidAuthError(e))
                            {
                                reject(new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e));
                            }
                            else
                            {
                                switch (e)
                                {
                                    case 'MIN_TRADE_REQUIREMENT_NOT_MET':
                                        reject(new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InvalidQuantity(self.getId(), pair, quantity, e));
                                        break;
                                    case 'DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT':
                                        reject(new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InvalidPrice(self.getId(), pair, targetRate, quantity, e));
                                        break;
                                    case 'INSUFFICIENT_FUNDS':
                                        reject(new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InsufficientFunds(self.getId(), pair, targetRate, quantity, e));
                                        break;
                                    default:
                                        reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                                        break;
                                }
                            }
                        }
                        else
                        {
                            reject(e);
                        }
                        return;
                    }
                    // only return order number
                    return resolve(response.result.uuid);
                });
            }
        });
    });
}

/**
 * Cancels an existing order
 *
 * @param {string} orderNumber number of the order to cancel
 * @param {string} pair pair (ex: USDT-NEO) (if exchange supports retrieving an order without the pair, value will be undefined)
 * @return {Promise} Promise which will resolve to true in case of success
 */
/*
 Raw output example for GET https://bittrex.com/api/v1.1/market/cancel?apikey=API_KEY&uuid=ORDER_UUID

{
    "success" : true,
    "message" : "",
    "result" : null
}

*/
_cancelOrder(orderNumber, pair)
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.cancel({uuid:orderNumber}, (response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        if (self._isInvalidAuthError(e))
                        {
                            reject(new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e));
                        }
                        else
                        {
                            switch (e)
                            {
                                case 'INVALID_ORDER':
                                    reject(new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber, e));
                                    break;
                                case 'ORDER_NOT_OPEN':
                                    reject(new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotOpen(self.getId(), orderNumber, e));
                                    break;
                                default:
                                    reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                                    break;
                            }
                        }
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                resolve(true);
            });
        });
    });
}

/**
 * Return balances for all currencies (currencies with balance = 0 should be filtered out)
 *
 * @return {Promise}
 */
/*
Raw output example for GET https://bittrex.com/api/v1.1/account/getbalances?apikey=API_KEY

*/
_getBalances()
{
    let self = this;
    return this._limiterGlobal.schedule(function(){
        return new Promise((resolve, reject) => {
            self._client.getbalances((response, error) => {
                if (null !== error)
                {
                    let e = self._parseError(error);
                    // must be a Bittrex error
                    if ('string' == typeof (e))
                    {
                        if (self._isInvalidAuthError(e))
                        {
                            reject(new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e));
                        }
                        else
                        {
                            reject(new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e));
                        }
                    }
                    else
                    {
                        reject(e);
                    }
                    return;
                }
                let list = {};
                _.forEach(response.result, (entry) => {
                    // ignore currency with 0 balance
                    let total = parseFloat(entry.Balance);
                    if (0 == total)
                    {
                        return;
                    }
                    let available = parseFloat(entry.Available);
                    let onOrders = total - available;
                    let b = {
                        currency:entry.Currency,
                        total:total,
                        available:available,
                        onOrders:onOrders
                    }
                    list[entry.Currency] = b;
                });
                resolve(list);
            });
        });
    });
}

}

module.exports = Exchange;
